<!DOCTYPE html>
<!-- saved from url=(0064)http://webglfundamentals.org/webgl/webgl-text-html-canvas2d.html -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
<link type="text/css" href="./WebGL Text - HTML Canvas2D_files/webgl-tutorials.css" rel="stylesheet">
<style>
* {
  box-sizing: border-box;
}
#ui {
    width: 200px;
}

.container {
    position: relative;
}

#text {
    background-color: transparent;  /* needed because webgl-tutoraisl.css sets canvas bg color to white */
    position: absolute;
    left: 0px;
    top: 0px;
    z-index: 10;
}

</style>
<script src="./resources/webgl-utils.js.download"></script>
<script src="./resources/webgl-lessons-helper.js.download"></script>
<script src="./resources/3d-math.js.download"></script>
</head>
<body>
<div class="container">
  <canvas id="canvas" width="800" height="480"></canvas>
  <canvas id="text" width="800" height="480"></canvas>
</div>

<!-- vertex shader -->
<script id="3d-vertex-shader" type="x-shader/x-vertex">
attribute vec4 a_position;
attribute vec4 a_color;
uniform mat4 u_matrix;
varying vec4 v_color;

void main() {
  // Multiply the position by the matrix.
  gl_Position = u_matrix * a_position;

  // Pass the color to the fragment shader.
  v_color = a_color;
}
</script>
<!-- fragment shader -->
<script id="3d-fragment-shader" type="x-shader/x-fragment">
precision mediump float;

// Passed in from the vertex shader.
varying vec4 v_color;

void main() {
   gl_FragColor = v_color;
}
</script>
<script>
"use strict";

 var latitudeBands = 30;
 var longitudeBands = 30;
 var radius = 2;
 
 var vertexPositionBuffer;
 var vertexNormalBuffer;
 var vertexTextureCoordBuffer;
 var vertexIndexBuffer;
var canvas;
var gl;

function main() {
  // Get A WebGL context
  /** @type {HTMLCanvasElement} */
  canvas = document.getElementById("canvas");
  webglLessonsHelper.setupLesson(canvas);
  gl = canvas.getContext("webgl");
  if (!gl) {
    webglLessonsHelper.showNeedWebGL(canvas);
    return;
  }

  // look up the text canvas.
  var textCanvas = document.getElementById("text");

  // make a 2D context for it
  var ctx = textCanvas.getContext("2d");

  // setup GLSL program
  var program = webglUtils.createProgramFromScripts(gl, ["3d-vertex-shader", "3d-fragment-shader"]);

  // look up where the vertex data needs to go.
  var positionLocation = gl.getAttribLocation(program, "a_position");
  var colorLocation = gl.getAttribLocation(program, "a_color");

  // lookup uniforms
  var matrixLocation = gl.getUniformLocation(program, "u_matrix");

  // Create a buffer to put positions in
  var positionBuffer = gl.createBuffer();
  // Bind it to ARRAY_BUFFER (think of it as ARRAY_BUFFER = positionBuffer)
  gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
  // Put geometry data into buffer

  // Create a buffer to put colors in
  var colorBuffer = gl.createBuffer();
  // Bind it to ARRAY_BUFFER (think of it as ARRAY_BUFFER = colorBuffer)
  gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);
  // Put geometry data into buffer
  function radToDeg(r) {
    return r * 180 / Math.PI;
  }

  function degToRad(d) {
    return d * Math.PI / 180;
  }

  var translation = [0, 30, -360];
  var rotation = [degToRad(190), degToRad(0), degToRad(0)];
  var scale = [1, 1, 1];
  var fieldOfViewRadians = degToRad(60);
  var rotationSpeed = 1.2;

  var then = 0;

  requestAnimationFrame(drawScene);

  // Draw the scene.
  function drawScene(clock) {
    // Convert to seconds
    clock *= 0.001;
    // Subtract the previous time from the current time
    var deltaTime = clock - then;
    // Remember the current time for the next frame.
    then = clock;

    // Every frame increase the rotation a little.

    webglUtils.resizeCanvasToDisplaySize(gl.canvas);
    webglUtils.resizeCanvasToDisplaySize(ctx.canvas);
	
    // Clear the 2D canvas
    ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
	ctx.font = "50px serif";
	ctx.textAlign = "center";
	
	ctx.fillText("Tap or click to place a node.", canvas.width/2,canvas.height *7/8);

	thing();
	
	
    requestAnimationFrame(drawScene);
  }
  
	
	function thing(){

		
		// Four Vertices
		
		var inputVertices = [
			0,1,1, 1,1,1, 1,1,0,
			0,1,1, 0,1,0, 1,1,0,

			0,1,1, 0,1,0, 0,0,1,
			0,1,1, 0,1,0, 0,0,0,
			1,1,0, 0,1,0, 0,0,0,
			1,1,0, 1,0,0, 0,0,0,
			1,1,0, 1,0,0, 1,0,1,
			1,1,0, 1,1,1, 1,0,1,
			1,1,0, 0,0,1, 1,0,1,
			0,1,1, 0,0,1, 1,1,1,
			0,0,0, 0,0,1, 1,0,0,
			0,0,1, 1,0,1, 1,0,0,
		];
		
		var vertices = [];
		var surfaceNormals = [];
		
		for(var i = 0; i < inputVertices.length; i = i + 9){
			var a = new vec3(inputVertices[i+0],inputVertices[i+1],inputVertices[i+2]);
			var b = new vec3(inputVertices[i+3],inputVertices[i+4],inputVertices[i+5]);
			var c = new vec3(inputVertices[i+6],inputVertices[i+7],inputVertices[i+8]);
			
			var vectorA = subtract(b,a);
			var vectorB = subtract(c,a);
			
			
			var normal = cross(vectorA,vectorB);
			
			normal[0] += .3;
			normal[1] += .3;
			normal[2] += .3;
			
			normal = normalize(normal);
			normal[3] =  0;
		
			surfaceNormals.push(normal);
			surfaceNormals.push(normal);
			surfaceNormals.push(normal);//cross product of b-a and c-a
			
			//normalize vector
			
			vertices.push(a);
			vertices.push(b);
			vertices.push(c);
			
		}

		
		points = vertices.length;
		//
		//  Configure WebGL
		//
		gl.viewport( 0, 0, canvas.width, canvas.height );
		gl.clearColor( 0.0, 0.0, 0.0, 1.0 );
		
		//  Load shaders and initialize attribute buffers
		
		program = initShaders( gl, "vertex-shader", "fragment-shader" );
		gl.useProgram( program );
		
		// Load the data into the GPU
		
		var bufferId = gl.createBuffer();
		gl.bindBuffer( gl.ARRAY_BUFFER, bufferId );
		gl.bufferData( gl.ARRAY_BUFFER, flatten(vertices), gl.STATIC_DRAW );

		// Associate out shader variables with our data buffer
		
		var vPosition = gl.getAttribLocation( program, "vPosition" );
		gl.vertexAttribPointer( vPosition, 3, gl.FLOAT, false, 0, 0 );
		gl.enableVertexAttribArray( vPosition );
		
		setRotation();
		
		
		var bufferId2 = gl.createBuffer();
		gl.bindBuffer( gl.ARRAY_BUFFER, bufferId2 );
		gl.bufferData( gl.ARRAY_BUFFER, flatten(surfaceNormals), gl.STATIC_DRAW );
		
		var vNormals = gl.getAttribLocation( program, "vNormal" );
		gl.vertexAttribPointer( vNormals, 3, gl.FLOAT, false, 0, 0 );
		gl.enableVertexAttribArray( vNormals );
		
		
		render();
		
	}

	function cross( a, b){ // [ a2 * b3 - a3 * b2, a3 * b1 - a1 * b3, a1 * b2 - a2 * b1 ]
		var vec = new vec3(a[1]*b[2]-a[2]*b[1],a[2]*b[0]-a[0]*b[2],a[0]*b[1]-a[1]*b[0]);
		return vec;
	}
	var matrix;
	function setRotation(){
		
		
		var x = document.getElementById("xSlider").value * 360/100;
		var y = document.getElementById("ySlider").value * 360/100;
		var z = document.getElementById("zSlider").value * 360/100;
		
		
		matrix = [
			1, 0,  0,  0,
			0, 1,  0,  0,
			0,  0, 1,  0,
			0,  0,  0,  1,
		];
		
		matrix = multiplyMatrix(matrix, rotateAlongX(x));
		matrix = multiplyMatrix(matrix, rotateAlongY(y));
		matrix = multiplyMatrix(matrix, rotateAlongZ(z));	
		
		var rotation = gl.getUniformLocation( program, "rotationMatrix" );
		gl.uniformMatrix4fv(rotation, false, matrix);
		
		gl.vertexAttribPointer( rotation, 3, gl.FLOAT, false, 0, 0 );
		gl.enableVertexAttribArray( rotation );
	}

	function rotateAll() {	
		setRotation();
		
		var bufferId = gl.createBuffer();
		gl.bindBuffer( gl.ARRAY_BUFFER, bufferId );
		render();

		// Set the matrix.
	}

	// returns a new matrix
	function multiplyMatrix(matrixA, matrixB) { 
		var result = [
			0, 0,  0,  0,
			0, 0,  0,  0,
			0,  0, 0,  0,
			0,  0,  0,  0];
			
		for (var i = 0; i < 4; i++) {
			for (var j = 0; j < 4; j++) {
				var sum = 0;
				for (var k = 0; k < 4; k++) {
					sum += matrixA[i*4+k] * matrixB[k*4+j];
				}
				result[i * 4 + j] = sum;
			}
		}
		return result; 
	}

	function rotateAlongX(angleInDegrees) {
		var angleInRadians = angleInDegrees * 0.0174533;
		
	  var sine = Math.sin(angleInRadians);
	  var cosine = Math.cos(angleInRadians);

	  return [
		1, 	0, 		0, 0,
		0, 	cosine, sine, 0,
		0, 	-sine, 	cosine, 0,
		0, 	0, 		0, 1
	  ];
	};

	function rotateAlongY(angleInDegrees) {
	  var angleInRadians = angleInDegrees * 0.0174533;
	  var sine = Math.sin(angleInRadians);
	  var cosine = Math.cos(angleInRadians);

	  return [
		cosine, 0, -sine, 0,
		0, 		1, 0, 0,
		sine, 	0, cosine, 0,
		0, 		0, 0, 1
	  ];
	};

	function rotateAlongZ(angleInDegrees) {
	  var angleInRadians = angleInDegrees * 0.0174533;
	  var sine = Math.sin(angleInRadians);
	  var cosine = Math.cos(angleInRadians);
	  return [
		 cosine, 	sine, 0, 0,
		-sine, 		cosine, 0, 0,
		 0, 		0, 1, 0,
		 0, 		0, 0, 1,
	  ];
	}
}
  


main();
</script>



</body></html>